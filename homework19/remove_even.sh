#!/bin/bash

set -euo pipefail

SRC_DIR="${1:-}"
# SRC_DIR — исходная директория из 1-го аргумента командной строки.
# "${1:-}" — parameter expansion:
#   если $1 не задан, подставить пустую строку вместо "ошибки" (важно при -u).
# Почему не просто "$1":
#   потому что при set -u обращение к $1 без аргумента вызовет ошибку и скрипт упадёт сразу.

DST_DIR="${2:-}"
# DST_DIR — директория назначения из 2-го аргумента.
# Аналогично "${2:-}" защищает от -u.

if [[ -z "$SRC_DIR" || -z "$DST_DIR" ]]; then
  # -z STRING — истина, если строка пустая.
  # || — логическое ИЛИ.
  echo "Использование: $0 <src_dir> <dst_dir>"
  # $0 — имя скрипта (для подсказки как запускать).
  exit 1
  # exit 1 — завершить скрипт с кодом ошибки 1.
fi

[[ -d "$SRC_DIR" ]] || { echo "Нет исходной директории: $SRC_DIR"; exit 1; }
# [[ -d PATH ]] — истина, если PATH существует и это директория.
# || — если условие ЛОЖЬ, выполняем блок справа.

mkdir -p "$DST_DIR"
# Создать целевую директорию, если её нет.
# -p — чтобы не падать, если уже существует.

for f in "$SRC_DIR"/*; do
  # Пробегаем по всем элементам в SRC_DIR.
  # Важно: "$SRC_DIR" в кавычках, а /* — снаружи, чтобы glob (звёздочка) работал.
  # Если бы было "$SRC_DIR/*" целиком в кавычках — звёздочка не раскрылась бы.

  [[ -f "$f" ]] || continue
  # [[ -f "$f" ]] — истина, если это обычный файл (не директория, не ссылка и т.п.).
  # continue — пропустить текущую итерацию цикла.
  # Зачем:
  #   если в папке окажутся директории/прочее — мы их игнорируем.

  name="$(basename -- "$f")"
  # basename — получить имя файла без пути.
  # -- — конец опций: если имя файла начинается с '-', basename не воспримет это как ключ.
  # $(...) — подстановка результата команды.

  last="${name: -1}"
  # Вырезаем последний символ строки:
  # ${var: offset : length}
  # offset = -1 означает "с конца 1 символ".
  # В bash пробел после ':' в "${name: -1}" важен для отрицательного офсета.

  if [[ "$last" =~ ^[02468]$ ]]; then
    # =~ — regex-матч в [[ ... ]].
    # ^[02468]$ — строка должна состоять ровно из одной цифры: 0/2/4/6/8.
    # То есть проверяем: последняя цифра имени файла чётная.
    mv -- "$f" "$DST_DIR/"
    # mv — переместить файл.
    # -- — конец опций (на случай имени файла вида "-123").
    # "$DST_DIR/" — слэш на конце не обязателен, но подчёркивает, что это директория.
  fi
done

echo -n "Осталось в odd: "
# echo -n — не добавлять перевод строки (хотим вывести число на этой же строке).

ls -1 "$SRC_DIR" 2>/dev/null | wc -l
# ls -1 — вывести по одному имени в строке (удобно считать wc -l).
# 2>/dev/null — спрятать сообщения об ошибке (например, если папка пустая и ls ругается/или нет доступа).
# | — pipe: вывод ls идёт на вход wc.
# wc -l — посчитать строки => количество имён => количество элементов.
# Примечание: это считает "элементы", которые показывает ls (обычно файлы/папки).

echo -n "Перенесено в even: "

find "$DST_DIR" -maxdepth 1 -type f | wc -l
# find — ищет объекты в файловой системе, начиная с указанного пути.
# "$DST_DIR" — стартовая директория поиска (в кавычках, чтобы путь с пробелами не ломал команду).
# -maxdepth 1 — глубина поиска 1: искать только внутри самой папки DST_DIR, без вложенных поддиректорий.
# -type f — отбирать только обычные файлы (directories/links не считаем).
# | — pipe: передаём список найденных файлов дальше.
# wc -l — считает количество строк, т.е. количество найденных файлов => “сколько файлов в DST_DIR”.

